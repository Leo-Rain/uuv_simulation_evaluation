#!/usr/bin/env python
# Copyright (c) 2016 The UUV Simulator Authors.
# All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import matplotlib
import signal
import argparse
import roslib
import os
import sys
import logging
import random
from time import sleep
from uuv_smac_utils import OptConfiguration, start_simulation_pool, \
    stop_simulation_pool

matplotlib.use('Agg')
roslib.load_manifest('uuv_smac_utils')

OPT_CONFIG = OptConfiguration.get_instance('opt_config.yml')

# Initializing SMAC_WRAPPER_LOGGER
SMAC_WRAPPER_LOGGER = logging.getLogger('smac_wrapper')

out_hdlr = logging.StreamHandler(sys.stdout)
out_hdlr.setFormatter(logging.Formatter('%(asctime)s | %(levelname)s | %(module)s | %(message)s'))
out_hdlr.setLevel(logging.INFO)
SMAC_WRAPPER_LOGGER.addHandler(out_hdlr)
SMAC_WRAPPER_LOGGER.setLevel(logging.INFO)

if not os.path.isdir('logs'):
    os.makedirs('logs')
log_filename = os.path.join('logs', 'smac_wrapper.log')

file_hdlr = logging.FileHandler(log_filename)
file_hdlr.setFormatter(logging.Formatter('%(asctime)s | %(levelname)s | %(module)s | %(message)s'))
file_hdlr.setLevel(logging.INFO)

SMAC_WRAPPER_LOGGER.addHandler(file_hdlr)
SMAC_WRAPPER_LOGGER.setLevel(logging.INFO)


def signal_handler(signal, frame):
    SMAC_WRAPPER_LOGGER.warning('SIGNAL RECEIVED=%d', int(signal))
    SMAC_WRAPPER_LOGGER.warning('Killing simulation pool...')
    stop_simulation_pool()
    sys.exit(0)


signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='SMAC wrapper')
    # SMAC fixed positional parameters
    #    <instance_name> <instance_specific_information> <cutoff_time> <cutoff_length> <seed>
    parser.add_argument(
        'instance_name',
        help='The name of the problem instance we are executing against')
    parser.add_argument(
        'instance_specific_information',
        help='An arbitrary string associated with this instance as specified in the instance file.')
    parser.add_argument(
        'cutoff_time', type=float,
        help='The amount of time in seconds that the target algorithm is permitted to run.')
    parser.add_argument(
        'cutoff_length', type=float,
        help='A domain specific measure of when the algorithm should consider itself done')
    parser.add_argument(
        'seed', type=int,
        help='A positive integer that the algorithm should use to seed itself (for reproducibility).')

    SMAC_WRAPPER_LOGGER.info('Adding parameters to the parser')
    for param_tag in OPT_CONFIG.parameters:
        parser.add_argument('-' + param_tag, type=float)
        SMAC_WRAPPER_LOGGER.info('\t -' + param_tag)

    args = parser.parse_args()

    OPT_CONFIG.parse_input(args)
    SMAC_WRAPPER_LOGGER.info('Input parameters=')
    for tag in OPT_CONFIG.params:
        SMAC_WRAPPER_LOGGER.info('\t - %s = %s' % (tag, str(OPT_CONFIG.params[tag])))

    status = ''

    output, failed_tasks = start_simulation_pool()
    sleep(5)

    cost = list()
    sim_time = list()
    tasks_status = list()

    total_cost = 0.0
    status = None

    try:
        for item in output:
            SMAC_WRAPPER_LOGGER.info(item['task'])
            SMAC_WRAPPER_LOGGER.info(item)

            if item['status'] == 'CRASHED':
                continue

            if status is None:
                status = item['status']

            cost.append(item['cost'])
            sim_time.append(item['sim_time'])
            tasks_status.append(item['status'])

        repeat_count = 0
        while len(failed_tasks) > 0 and repeat_count < 3:
            SMAC_WRAPPER_LOGGER.info('Running failed tasks: %s' % str(failed_tasks))
            output, failed_tasks = start_simulation_pool(1, failed_tasks)
            sleep(5)

            status = None
            for item in output:
                SMAC_WRAPPER_LOGGER.info(item['task'])
                SMAC_WRAPPER_LOGGER.info(item)

                if item['status'] == 'CRASHED':
                    continue

                if status is None:
                    status = item['status']

                cost.append(item['cost'])
                sim_time.append(item['sim_time'])
                tasks_status.append(item['status'])

            if len(failed_tasks) == 0:
                break
            repeat_count += 1

        if len(failed_tasks) == 0:
            total_time = sum(sim_time)
            total_cost = sum([cost[i] * sim_time[i] / total_time for i in range(len(cost))])
            SMAC_WRAPPER_LOGGER.info('All costs: %.2f' % total_cost)
            for i in range(len(cost)):
                SMAC_WRAPPER_LOGGER.info('\t%d - Cost=%.2f - Timeout=%.2f s' % (i, cost[i], sim_time[i]))
        else:
            status = 'CRASHED'
            total_cost = 1e7
    except Exception as ex:
        template = "An exception of type {0} occurred. Arguments:\n{1!r}"
        message = template.format(type(ex).__name__, ex.args)
        SMAC_WRAPPER_LOGGER.error('Exception occured, message=' + message)
        SMAC_WRAPPER_LOGGER.error('Simulation interrupted, finishing simulation pool')
        stop_simulation_pool()
        SMAC_WRAPPER_LOGGER.error('Simulation pool ended')
        status = 'CRASHED'
        total_cost = 1e7

    sleep(2 * random.random())

    print('Result for SMAC: %s, 0, 0, %f, %s' % (status, total_cost, args.seed))
